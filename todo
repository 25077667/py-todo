#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import sys
import pickle
import re
import math
from enum import IntEnum
from pathlib import Path
from datetime import datetime
from datetime import timedelta

""" Define config and data file locations """
config_location = str(Path.home()) + '/.config/py-todo/'
datafile_location = str(Path.home()) + '/.local/share/py-todo/'

""" Define config and data file names """
config_name = 'config'
datafile_name = 'todo.dat'

""" Create dictionary representing the config file """
config = {
    'detail_mode': 'false',
    'color': 'false'
}

""" Define colors """
index_color = '\x1b[34m{}\x1b[0m'
date_color = '\x1b[32m{}\x1b[0m'
due_color = '\x1b[31m{}\x1b[0m'
today_color = '\x1b[33m{}\x1b[0m'

""" Regex for removing terminal escape sequences from a string """
esc_seq_reg = re.compile(r'\x1b[^m]*m')

""" List of TodoItems, to be stored later in the datafile """
items = []


class TodoItem:
    """ A class definition for each todo item, which is defined with todo -a, and stored in the datafile """
    def __init__(self, title: str, exp_date: datetime):
        self.title = title
        self.exp_date = exp_date  # Expiration date, type: datetime

    def __str__(self):
        if self.exp_date is None:
            return self.title
        
        # Set the amount of days left as the timedelta from today to the expiration date, in days.
        days_left = (self.exp_date - datetime.today()).days + 1

        if days_left == 0:
            return self.title + " (Today)"  # Annotate as the current day
        elif days_left == 1:
            return self.title + " (Tomorrow)"  # Annotate as tomorrow
        elif days_left > 1:
            output_str = self.title + " ("
            
            # If in detail mode, annotate more explicitly (i.e. give the due weekday)
            if 'detail_mode' in config and config['detail_mode'] in ['true', 'True']:
                # Calculate weeks_left to determine the event is in this or the next week.
                weeks_left = int((self.exp_date - datetime.today()).days / 6)  # Divide by six because zero indexing
                
                # weeks_left == 0 implies this week;
                # weeks_left == 1 implies next week.
                if weeks_left == 0 or weeks_left == 1:
                    output_str += f"{'This' if weeks_left == 0 else 'Next'} {self.exp_date.strftime('%A')}; "
            return output_str + f"{days_left} days left)"
        else:
            return self.title + " (DUE!)"

    def __eq__(self, other):
        """ Override default equality """
        if isinstance(other, TodoItem):
            return (self.title == other.title) and (self.exp_date == other.exp_date)
        return False


def maybe_color_str(message, color_fstr, predicate=lambda: True):
    """Colors a string with color_fstr if the config has the color flag set to true

    :param message: The message to possibly colorize
    :param color_fstr: The color fomat string
    :param predicate: A function deciding whether the message should be colored, alongside the config file
    :return: A colored string if the config indicated color
    """
    if config['color'] in ['true', 'True']:
        stripped_message = esc_seq_reg.sub('', message)
        return color_fstr.format(stripped_message) if predicate() else message

    return message


def add_item(title: str, exp_date: datetime):
    """ Adds a TodoItem to the items list """
    items.append(TodoItem(title, exp_date))


def insert_todo_item(index, todo_item):
    """Inserts a TodoItem into the items list at a given index

    :param index: The index to insert at
    :param todo_item: The item to insert
    """
    items.insert(index, todo_item)


def remove_item(indices: list):
    """ Removes a TodoItem from the items list """
    for index in sorted(indices, reverse=True):
        del items[index]


def list_items():
    """ Iterate through each TodoItem in the items list and print it """
    if len(items) > 0:
        print(f"You have {len(items)} item{'s' if len(items) >= 2 else ''} left on the reminder!")

        for index, item in enumerate(items):
            item_str = str(item)
            index = str(index)

            maybe_colored_index = maybe_color_str(index + ") ", index_color)

            if '(' in item_str:
                date = item_str[item_str.index('('):]  # Slice of str from the first occurrence of "(" (inclusive)

                # The date could possibly be either color, so no harm in calling maybe_color_str multiple times
                date = maybe_color_str(date, due_color, lambda: True if "DUE" in date else False)
                date = maybe_color_str(date, date_color, lambda: True if "DUE" not in date else False)
                date = maybe_color_str(date, today_color, lambda: True if "Today" in date else False)

                print(maybe_colored_index + item.title + " " + date)
            else:
                print(maybe_colored_index + item_str)


def parse_date_str(exp_date_str):
    """Parses a date string and returns a datetime object

    :param exp_date_str: the date string to validate
    :return: a valid datetime object
    """
    try:
        if exp_date_str == '':
            return None
        elif exp_date_str.endswith('d'):
            day_count = int( exp_date_str.split('d')[0] )
            return datetime.today() + timedelta(days=day_count)
        else:
            return datetime(*map(int, exp_date_str.split('/')))
    except:
        print("An error occurred while parsing your date.")
        sys.exit()


def print_usage():
    print()
    print("Usage: " + sys.argv[0] + " <argument>")
    print("-a --add                                  -- Add a new item.")
    print("-a --add <title> <date or days>           -- Add a new item with a title and expiry date provided.")
    print("-e --edit <index>                         -- Edit an item.")
    print("-e --edit <index> <title> <date or days>  -- Edit an item with a title and expiry date provided.")
    print("-r --remove <indices...>                  -- Remove items by their indices.")
    print("-l --list                                 -- List all items.")
    print("-org --orgfile <filename>                 -- Add org file TODOs.")
    print()
    print("-h --help                                 -- Display help message.")
    print("-v --version                              -- Display version info.")
    print('\n')
    print("Configuration Options (See " + config_location + config_name + "):")
    print("* color = true / false")
    print("* detail_mode = true / false")


def print_version():
    print("py-todo 1.3.2")
    print("Copyright (C) 2018 Marco Wang")
    print()
    print("This is free software, see the source for copying conditions.  There is NO")
    print("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE")


def take_input(title_pos, date_pos, default_title=None):
    """Takes a title and date from the user if not present in sys.argv

    :param title_pos: the position of the title in sys.argv
    :param date_pos: the position of the date in sys.argv
    :param default_title: the default value for the title
    :return: a tuple containing the title and date
    """
    if default_title:
        title = sys.argv[title_pos] if len(sys.argv) > title_pos else input(f"Title ({default_title}): ")
    else:
        title = sys.argv[title_pos] if len(sys.argv) > title_pos else input("Title: ")
    
    exp_date_str = sys.argv[date_pos] if len(sys.argv) > date_pos else input("Expiry date (YYYY/MM/DD or <days>d) (Optional): ")

    return title if title else default_title, exp_date_str


if __name__ == '__main__':
    # mkdir -p on config_location and datafile_location.
    Path(config_location).mkdir(parents=True, exist_ok=True)
    Path(datafile_location).mkdir(parents=True, exist_ok=True)

    # Try to load user configuration.
    try:
        with open(config_location + config_name, 'r') as f:
            for line in f:
                if not line.startswith('#'):
                    key, val = line.replace(' ', '').split('=')
                    config[key] = val.rstrip('\n')
    except FileNotFoundError:
        pass

    # Try to unpickle todo list from the file.
    try:
        with open(datafile_location + datafile_name, 'rb') as f:
            items = pickle.load(f)
    except:
        pass

    # Command line argument parsing.
    if len(sys.argv) <= 1:
        list_items()

    elif sys.argv[1] == '-l' or sys.argv[1] == '--list':
        list_items()

    elif sys.argv[1] == '-a' or sys.argv[1] == '--add':
        try:
            title, exp_date_str = take_input(2, 3)
            
            exp_date = parse_date_str(exp_date_str)
            add_item(title, exp_date)
            list_items()
        except KeyboardInterrupt:
            # If the input is canceled, print a newline for prettiness, list the items and exit
            print()
            list_items()
            sys.exit()

    elif sys.argv[1] == '-r' or sys.argv[1] == '--remove':
        if len(sys.argv) >= 3:
            try:
                indices = list(map(int, sys.argv[2:]))
                remove_item(indices)
                list_items()
            except:
                print("Item does not exist.")
        else:
            print_usage()

    elif sys.argv[1] == '-e' or sys.argv[1] == '--edit':
        if len(sys.argv) >= 3:
            try:
                item = items[int(sys.argv[2])]
                title, exp_date_str = take_input(3, 4, default_title=item.title)

                item.title = title
                item.exp_date = parse_date_str(exp_date_str)
                list_items()
            except IndexError:
                print("Item does not exist.")
                sys.exit()
            except KeyboardInterrupt:
                # If the input is canceled, print a newline for prettiness, list the items and exit
                # We don't need to re-add the old item here because if input is canceled, we never actually changed it
                print()
                list_items()
                sys.exit()
        else:
            print_usage()

    elif sys.argv[1] == '-org' or sys.argv[1] == '--orgfile':
        keywords = []
        filename = str(sys.argv[2])
        # Open the orgfile
        with open(filename, 'r') as f:
            content = f.readlines()
            for index, line in enumerate(content):
                # Search for the header to obtain the keywords
                if "#+TODO:" in line:
                    todos = line.replace('#+TODO: ', '')
                    for word in todos.split():
                        if word != '|':
                            keywords.append(word)
                else:
                    if not keywords:
                        keywords.append('TODO')
                        keywords.append('DONE')
                    for word in keywords:
                        # Search in each line and format if match
                        if word in line and '*' in line:
                            line = line.strip('*')
                            line = line.replace(word, '')
                            line = line.strip()
                            title = line
                            try:
                                if ': <' in content[index + 1]:
                                    line, date = content[index + 1].split('<')
                                    match = re.search(r'\d{4}-\d{2}-\d{2}', date)
                                    date = match.group(0)
                                    date = datetime(*map(int, date.split('-')))
                                    exp_date = date
                                    add_item(title, exp_date)
                                else:
                                    date = None
                                    exp_date = date
                                    add_item(title, exp_date)
                            except IndexError:
                                date = None
                                exp_date = date
                                add_item(title, exp_date)
        list_items()
 
    elif sys.argv[1] == '-v' or sys.argv[1] == '--version':
        print_version()

    else:
        print_usage()

    # Write all changes back to the file.
    with open(datafile_location + datafile_name, 'wb') as f:
        pickle.dump(items, f)
